const path = require('path');
const fs = require('fs');
const YAML = require('yaml');

async function bundleOAS() {
  // Change working directory to project root first
  const originalCwd = process.cwd();

  try {
    process.chdir(path.resolve(__dirname, '..'));

    const inputPath = './oas/lke/lke.openapi.yaml';
    const componentsPath = './oas/lke/components.openapi.yaml';
    const outputDir = './docs/api/lke';
    const outputPath = path.join(outputDir, 'lke.openapi.yaml');
    const readmePath = path.join(outputDir, 'IMPORTANT.md');

    fs.mkdirSync(outputDir, { recursive: true });

    console.log('Starting OpenAPI bundle process...');
    console.log('Input file:', inputPath);

    // Read and parse main OpenAPI file
    const mainContent = fs.readFileSync(inputPath, 'utf8');
    const mainOAS = YAML.parse(mainContent);

    // Read and parse components file
    let componentsOAS = {};
    if (fs.existsSync(componentsPath)) {
      const componentsContent = fs.readFileSync(componentsPath, 'utf8');
      componentsOAS = YAML.parse(componentsContent);
      console.log('Components file loaded successfully');
    }

    // Merge components into main OAS
    if (componentsOAS.components) {
      if (!mainOAS.components) {
        mainOAS.components = {};
      }

      // Merge each component section
      Object.keys(componentsOAS.components).forEach(componentType => {
        if (!mainOAS.components[componentType]) {
          mainOAS.components[componentType] = {};
        }
        Object.assign(mainOAS.components[componentType], componentsOAS.components[componentType]);
      });

      console.log('Components merged successfully');
    }

    // Replace external references with internal ones
    const bundledOAS = replaceExternalReferences(mainOAS);

    // Clean up any malformed refs
    const cleanedOAS = cleanMalformedRefs(bundledOAS);

    const yamlContent = YAML.stringify(cleanedOAS, {
      indent: 2,
      lineWidth: 0,
      minContentWidth: 0,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      quotingType: '"',
      forceQuotes: false
    });

    fs.writeFileSync(outputPath, yamlContent, 'utf8');
    console.log('Bundle OAS created successfully in:', outputPath);

    const aviso = `# IMPORTANT WARNING

**DO NOT EDIT THE ".yaml" AND ".mdx" FILES DIRECTLY IN THIS FOLDER!**

These files are automatically generated by the \`npm run apidocs\` script.

Any manual changes will be lost in the next automatic generation.

To modify the documentation or OpenAPI specification, edit the appropriate source files in the \`oas\` folder.

## How to edit

1. Edit the files in \`oas/lke/\`
2. Run \`npm run apidocs\` to regenerate
3. Check the result in this folder

## Source files structure

- \`oas/lke/lke.openapi.yaml\` - Main specification file
- \`oas/lke/components.openapi.yaml\` - Reusable components
- \`oas/base/base.openapi.yaml\` - Shared base components
`;

    fs.writeFileSync(readmePath, aviso, 'utf8');
    console.log('IMPORTANT.md created in:', readmePath);

    validateResult(cleanedOAS);
    console.log('Bundle validated successfully!');

    // Restore original working directory
    process.chdir(originalCwd);

  } catch (error) {
    // Restore original working directory in case of error
    process.chdir(originalCwd);
    console.error('Error creating OAS bundle:', error);
    console.error('Stack:', error.stack);
    process.exit(1);
  }
}

function replaceExternalReferences(obj) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(item => replaceExternalReferences(item));
  }

  const replaced = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key === '$ref' && typeof value === 'string') {
      // Replace external component references with internal ones
      if (value.startsWith('./components.openapi.yaml#/components/')) {
        replaced[key] = value.replace('./components.openapi.yaml#/components/', '#/components/');
      } else {
        replaced[key] = value;
      }
    } else {
      replaced[key] = replaceExternalReferences(value);
    }
  }

  return replaced;
}

function cleanMalformedRefs(obj) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(item => cleanMalformedRefs(item));
  }

  const cleaned = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key === '$ref' && typeof value === 'string') {
      if (value.includes('~1') || value.includes('~0') || value.includes('%')) {
        console.warn(`Malformed reference found and removed: ${value}`);
        continue;
      }
    }

    cleaned[key] = cleanMalformedRefs(value);
  }

  return cleaned;
}

function validateResult(oas) {
  if (!oas.openapi) {
    throw new Error('Invalid OpenAPI specification: openapi field is missing');
  }

  if (!oas.info) {
    throw new Error('Invalid OpenAPI specification: info field is missing');
  }

  if (!oas.paths) {
    throw new Error('Invalid OpenAPI specification: paths field is missing');
  }

  const yamlString = YAML.stringify(oas);
  const problematicRefs = yamlString.match(/#\/[^"\s]*~1[^"\s]*/g);

  if (problematicRefs) {
    console.warn('Malformed references found:', problematicRefs.slice(0, 5));
  }

  const pathCount = Object.keys(oas.paths).length;
  const componentCount = oas.components ? Object.keys(oas.components).reduce((acc, type) => {
    return acc + (oas.components[type] ? Object.keys(oas.components[type]).length : 0);
  }, 0) : 0;

  console.log(`Validation: ${pathCount} endpoints processed, ${componentCount} components included`);
}

bundleOAS().catch((err) => {
  console.error('Fatal error executing bundle:', err);
  process.exit(1);
});
