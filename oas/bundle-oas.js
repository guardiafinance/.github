const path = require('path');
const fs = require('fs');
const YAML = require('yaml');
const $RefParser = require('@apidevtools/json-schema-ref-parser');

async function bundleOAS() {
  try {
    const inputPath = path.resolve(__dirname, '../oas/lke/lke.openapi.yaml');
    const outputDir = path.resolve(__dirname, '../docs/api/lke');
    const outputPath = path.join(outputDir, 'lke.openapi.yaml');
    const readmePath = path.join(outputDir, 'IMPORTANT.md');

    fs.mkdirSync(outputDir, { recursive: true });

    console.log('Starting OpenAPI bundle process...');
    console.log('Input file:', inputPath);

    const oas = await $RefParser.dereference(inputPath, {
      continueOnError: false,
      dereference: {
        circular: false,
        excludedPathMatcher: () => false
      }
    });

    console.log('References resolved successfully!');

    const cleanedOAS = cleanMalformedRefs(oas);

    const yamlContent = YAML.stringify(cleanedOAS, {
      indent: 2,
      lineWidth: 0,
      minContentWidth: 0,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      quotingType: '"',
      forceQuotes: false
    });

    fs.writeFileSync(outputPath, yamlContent, 'utf8');
    console.log('Bundle OAS created successfully in:', outputPath);

    const aviso = `# IMPORTANT WARNING

**DO NOT EDIT THE ".yaml" AND ".mdx" FILES DIRECTLY IN THIS FOLDER!**

These files are automatically generated by the \`npm run apidocs\` script.

Any manual changes will be lost in the next automatic generation.

To modify the documentation or OpenAPI specification, edit the appropriate source files in the \`oas\` folder.

## How to edit

1. Edit the files in \`oas/lke/\`
2. Run \`npm run apidocs\` to regenerate
3. Check the result in this folder

## Source files structure

- \`oas/lke/lke.openapi.yaml\` - Main specification file
- \`oas/lke/components.openapi.yaml\` - Reusable components
- \`oas/base/base.openapi.yaml\` - Shared base components
`;

    fs.writeFileSync(readmePath, aviso, 'utf8');
    console.log('IMPORTANT.md created in:', readmePath);

    validateResult(cleanedOAS);
    console.log('Bundle validated successfully!');

  } catch (error) {
    console.error('Error creating OAS bundle:', error);
    console.error('Stack:', error.stack);
    process.exit(1);
  }
}

function cleanMalformedRefs(obj) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(item => cleanMalformedRefs(item));
  }

  const cleaned = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key === '$ref' && typeof value === 'string') {
      if (value.includes('~1') || value.includes('~0') || value.includes('%')) {
        console.warn(`Malformed reference found and removed: ${value}`);
        continue;
      }
    }

    cleaned[key] = cleanMalformedRefs(value);
  }

  return cleaned;
}

function validateResult(oas) {
  if (!oas.openapi) {
    throw new Error('Invalid OpenAPI specification: openapi field is missing');
  }

  if (!oas.info) {
    throw new Error('Invalid OpenAPI specification: info field is missing');
  }

  if (!oas.paths) {
    throw new Error('Invalid OpenAPI specification: paths field is missing');
  }

  const yamlString = YAML.stringify(oas);
  const problematicRefs = yamlString.match(/#\/[^"\s]*~1[^"\s]*/g);

  if (problematicRefs) {
    console.warn('Malformed references found:', problematicRefs.slice(0, 5));
  }

  const pathCount = Object.keys(oas.paths).length;
  console.log(`Validation: ${pathCount} endpoints processed`);
}

bundleOAS().catch((err) => {
  console.error('Fatal error executing bundle:', err);
  process.exit(1);
});
